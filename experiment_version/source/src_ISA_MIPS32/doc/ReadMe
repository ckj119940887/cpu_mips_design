流水线存在的数据相关问题：1)RAW；2)WAR；3)WAW
因为我们采用的是五级流水线：IF->ID->EX->MEM->WB
其中2)和3)便不存在了，i指令在j指令之前，肯定在i指令执行完R和W后，才能执行j指令的W
j指令在ID阶段就要读取相应的寄存器

没解决的问题是RAW,存在如下三种情况
1)相邻指令间存在数据相关
i指令：IF->ID->EX->MEM->WB
j指令：    IF->ID->EX->MEM->WB
i指令和j指令之间差了两个阶段
该问题解决方案：将EX阶段的结果作为ID阶段的输出，如果EX阶段要写的寄存器和ID阶段要读的寄存器相同，直接将EX的数给ID

2)相隔1条指令间存在的数据相关
i指令：IF->ID->EX->MEM->WB
x指令：	  IF->ID->EX->MEM->WB
j指令：        IF->ID->EX->MEM->WB
该问题解决方案：将MEM阶段的结果作为ID阶段的输出，如果MEM阶段要写的寄存器和ID阶段要读的寄存器相同，直接将EX的数给ID

3)相隔2条指令间存在的数据相关
i指令：IF->ID->EX->MEM->WB
x指令：	  IF->ID->EX->MEM->WB
y指令：		  IF->ID->EX->MEM->WB
j指令：            IF->ID->EX->MEM->WB

针对情况3)，Regfile中已经考虑了这一点：
其中在读寄存器阶段（有两个读端口）
if( (raddr1 == waddr) && (we == `WriteEnable) && (re1 == `ReadEnable) )
	rdata1 <= wdata
即如果要写的寄存器和要读的寄存器相同，那么将要写入的结果直接作为结果输出

解决情况1)和3)的方法有如下三种：
a.插入暂停周期
b.编译器调度
c.数据前推（将计算结果从产生处直接送到其他指令需要处或需要的功能单元处，从而避免流水线暂停）
该方法一个潜在的基础就是，新的值需要在EX阶段(情况1)计算出来。特例是加载指令，其结果只有在MEM阶段才能获得
